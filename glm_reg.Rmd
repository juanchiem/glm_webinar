---
title: "GLM regresion"
output: html_document
date: '2022-06-09'
editor_options: 
  chunk_output_type: console
---

# Session setup 

Cargamos paquetes de utilidad para esta sesión y configuramos la estetica global de los graficos. 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
pacman::p_load(tidyverse,  # manipulacion general de datos
               lme4,       # ajuste de modelos mixtos
               DHARMa,     # diagnosticos
               sjPlot,     # visualizacion de outputs
               emmeans,    # estimacion de medias predichas por los modelos y comparaciones
               ggeffects,  # predicciones
               multcomp)   # letras de test de comparaciones multiples

theme_set(theme_bw())

# agregamos una funcion de ploteado rapido 

# gghist <- function(x, e, m){
#   ggplot() + 
#     aes(x)+ 
#     geom_histogram(binwidth=1, colour="gray30", fill="gray70") + 
#     geom_vline(xintercept = e, col="blue")+
#     geom_vline(xintercept = m, col="red", linetype="dashed")
# }
```

# Demos

## Dist. Normal

```{r}
set.seed(1)
x <- rnorm(n=100,    # sample size
          mean=10,  # mean of sample
          sd=3      # standard deviation of sample
         )
head(x)
mean(x)
sd(x)
gghist(x, e=10, m=mean(x))

mu = 3 + 2*x      # linear prediction
plot(x, mu)

# generamos el componente aleatorio distribucion normal de los errores
# set.seed(1)
y  <- mu + rnorm(100, 0, 3)

plot(x,y)
```

## Modelo lineal

```{r}
mod1 <- lm(y~x)
plot_model(mod1, type='pred', show.data=T, ci.lvl = NA)
summary(mod1)
```

De este modelo entendemos que cuando x=0, y=2.89 y por cada aumento unitario de x, y aumenta 1.99 unidades

y = 2.89 + 1.99 * x

Ahora veamos el mismo ajuste usando "glm" 

```{r}
mod1.1 <- glm(y~x, family = gaussian)
plot_model(mod1.1, type='pred', show.data=T, ci.lvl = NA)
summary(mod1.1)
```

y = 2.89 + 1.99 * x

Exactamente los mismos coeficientes que mod1

```{r}
gaussian()
binomial()
poisson()
```

## Dist. Binomial

Entendamos la naturaleza binaria de la incidencia. 

Imaginemos que estamos entrando en un campo de soja y queremos estimar la incidencia de una enfermedad foliar X

Una estacion (unidad) de muestreo de tamaño 30

```{r}
set.seed(1)

bin_1 <- rbinom(
  1,        # numero de observaciones o simulaciones (estaciones de muestreo)
  size=30,  # numero de ensayos (n) 
  p=0.1     # probabilidad de exito (p)
)
bin_1
bin_1/30    # 1 valor de incidencia de estacion de muestreo

# 0.066 -> 6,6% incidencia media del lote

# gghist(bin_1, e=30*0.1, m = mean(bin_1))
```

10 estaciones de muestreo de tamaño 30

```{r}
set.seed(1)

bin_2 <- rbinom(
  10,       # numero de observaciones
  size=30,  # numero de ensayos (n) 
  p=0.1     # probabilidad de exito (p)
)
bin_2       # muestra compuesta de 10 estaciones de muestreo con n=30 
bin_2/30    # 10 valores de incidencia de n=30

# gghist(bin_2, e=30*0.1, m=mean(bin_2)) 

mean(bin_2/30) 
# 0.11 -> 11% incidencia media del lote
```

100 estaciones de muestreo de tamaño 30

```{r}
set.seed(1)
bin_3 <- rbinom(
  100,    # numero de observaciones
  size=30,  # numero de ensayos 
  p=0.1     # probabilidad de exito
)
bin_3

# gghist(bin_3, e=30*0.1, m=mean(bin_3)) 
bin_3/30 # 100 valores de incidencia de n=30
mean(bin_3/30) 
# 0.101 -> 10.1% incidencia media del lote
```

```{r}
# media = np 
media_field = 30*0.1
media_field

# varianza  = np(1−p) 
varianza_field =  30*0.1*(1-0.1)
varianza_field

# sd = sqrt(np(1−p)) 
sd_field =  sqrt(30*0.1*(1-0.1))
sd_field
# sd_field =  1.643168
```

Variable aleatoria $X$ que es distribuida $X∼binomial(n,p)$ con media $μ = np$ y  varianza $σ2=np(1−p)$, siendo $X$ el conteo de eventos exitosos en $n$ idénticos e independientes ensayos Bernoulli con probabilidad de éxitos $p$ constante.

# DBCA

```{r}
# phom_raw <- import("https://raw.githubusercontent.com/juanchiem/agro_data/master/phomopsisp.csv") %>% tibble
phom_raw <- rio::import("madden/phomopsisp.csv", sep = ",") %>% tibble
```

**Efecto de tratamientos de fungicidas sobre tizon foliar por Phomopsis en frutilla (Nita, Madden & Ellis)**

- Patogeno: *Phomopsis obscurans*

- Diseño en bloques completos aleatorizados (RCBD)

- Cuatro bloques (bk, j = 1, ..., 4) 

- Ocho tratamientos (trt, i = 1, ..., 8) aleatorizados dentro de cada bloque 

- Variable respuesta (Y): incidencia de foliolos 

- Numero de foliolos enfermos de un total n


> Madden, L. V., W. W. Turechek, and M. Nita. "Evaluation of generalized linear mixed models for analyzing disease incidence data obtained in designed experiments." *Plant Disease* 86.3 (2002): 316-325.

#· Visualización

```{r}
phom_raw

# Calculamos la incidencia en proporcion 

phom_dat <- phom_raw %>% 
  mutate_at(vars(trt, bk), as.factor) %>% 
  mutate(inc=y/n)
```

```{r}
phom_dat %>% 
  ggplot() + 
  aes(x=trt, y = inc) + 
  geom_boxplot(alpha=.5, width = .2) + 
  geom_point(alpha=.7) + 
  labs(x="Tratamientos", y="Incidencia (proporción)")
```

# · Ajuste modelo

```{r}
mod_phom1 <- glmer(cbind(y, n-y) ~ trt + (1|bk),
               family="binomial",
               # weights = n,
               data=phom_dat)
summary(mod_phom1)
```

```{r}
mod_phom <- glmer(inc ~ trt + (1|bk), 
               family="binomial", 
               weights = n,
               data=phom_dat)
summary(mod_phom)
```

```{r}
tab_model(mod_phom1, mod_phom)
```

```{r}
em_phom <- emmeans(mod_phom, ~ trt, type="response")
res_phom <- cld(em_phom, Letters = letters, alpha = .05, type = "response")
knitr::kable(res_phom)
```


```{r}
mod_phom2 <- lmer(inc ~ trt + (1|bk), data=phom_dat)
summary(mod_phom2)
em_phom_LM <- emmeans(mod_phom2, ~ trt, type="response")
res_phom_LM <- cld(em_phom_LM, Letters = letters, alpha = .05, type = "response")
knitr::kable(res_phom_LM)
```

• Los errores estándar estimados (SE) son todos incorrectos (por definición), deben ser funciones de la media para datos binomiales [deben ser proporcionales a p(1-p)]

• Los SE incorrectos darán pruebas incorrectas de significación para los efectos del tratamiento y conducirán a conclusiones incorrectas


# Reg. Logistica

## Data maracuya

```{r}
raw <- rio::import("david/maracuya_geno.txt", header=TRUE) %>% tibble
# raw <- rio::import("david/maracuya_geno.txt", header = TRUE) %>% tibble 

dat <- raw %>%  
  mutate_at(vars(geno, bk), as.factor) %>% 
  mutate(inc_prop=dis_plants/n_plants, 
         plot = interaction(bk,geno))  # %>% 

dat %>%
    ggplot() +
    aes(x=days, y=inc_prop, col=geno, shape=bk)+
    geom_point()+
    geom_line(aes(group=interaction(bk,geno))) 
```

Filtramos el dataset completo para subsets menores

```{r}
# solo una evaluación a los 60 dias 
dat60 <- dat %>% 
  filter(days %in% c(60))

# solo una evaluación a los 90 dias 
dat90 <- dat %>% 
  filter(days %in% c(90))

# Dos evaluaciones: a los 60 y 90 dias 
dat60_90 <- dat %>% 
  filter(days %in% c(60, 90)) # %>% 
  # mutate_at(vars(days), as.factor) 
```

## Modelos 

y = inc_prop

Efectos aleatorios sobre las niveles de agrupamiento experimental 
(bloques o parcelas=bloque:geno)


Un solo momento de evaluacion 

# · 60 d

```{r}
dat60
dat60 %>% 
  ggplot() + 
  aes(x=geno, y=inc_prop) + 
  geom_jitter(alpha=.5, width=.02)
```


```{r}
# mod1 <- glmer(
#   cbind(dis_plants, n_plants-dis_plants) ~ geno + (1|bk), 
#   family="binomial", 
#   data=dat60) 

mod1 <- glmer(
  inc_prop ~ geno + (1|bk), # bloque como efecto aleatorio
  weights=n_plants,         
  family="binomial", 
  data=dat60) 

car::Anova(mod1)
summary(mod1)
# vemos que el geno A tiene un log odds medio de -2.125 y
# el geno B = -2.125 + (-0.1483)
```


```{r}
tab_model(mod1)
plot_model(mod1, type='pred', show.data=T,   bpe.color ="red")
```

Otro gran aliado es el paquete "emmeans" quien nos devuelve las estimaciones en proporcion ahorrandonos muchos calculos manuales 

```{r}
em1 <- emmeans(mod1, ~ geno, type="response")
res1 <- cld(em1, Letters = letters, alpha = .05, type = "response")
knitr::kable(res1)
```

# · 90 d

```{r}
dat90

dat90 %>% 
  ggplot() + 
  aes(x=geno, y=inc_prop) + 
  geom_point()

# mod1 <- glmer(
#   cbind(dis_plants, n_plants-dis_plants) ~ geno + (1|bk), 
#   family="binomial", 
#   data=dat60)
```


```{r}
mod2 <- glmer(
  inc_prop ~ geno + (1|bk),
  weights=n_plants,
  family="binomial", 
  data=dat90)

# boundary (singular) fit: see help('isSingular') puede deberse al bajo numero de bk
```


```{r}
car::Anova(mod2)
summary(mod2)
```

Vemos que ahora si, el geno tiene efecto significativo sobre la incidencia de la enfermedad

```{r}
tab_model(mod2)
```

podemos decir que la chance de presentar la enfermedad del genotipo B es 71% (1 - 0.29 = 0.71 * 100) menor en relacion al geno A

```{r}
plot_model(mod2, type='pred', show.data=T)
```


```{r}
em2 <- emmeans(mod2, ~ geno, type="response")
res2 <- cld(em2, Letters = letters, alpha = .05, type = "response")
knitr::kable(res2)
```


```{r}
odds_A = 0.37/(1-0.37)
odds_B = 0.15/(1-0.15)
odds_B/odds_A
```

Incluyendo una interaccion 

# · 60 y 90 d 

```{r}
dat60_90

dat60_90 %>% 
  ggplot() +
  aes(x=days, y=inc_prop, col=geno, shape=bk)+
  geom_point()
```


```{r}
mod3 <- glmer(inc_prop ~ geno * days + 
                (1|bk) + (1|bk:geno),
              weights=n_plants,
              family="binomial",
              data=dat60_90) 

car::Anova(mod3)

```

Removiendo la interaccion, dejando como efectos simples geno y dias


```{r}
mod3.1 <- glmer(inc_prop ~ geno + days + 
                  (1|bk) + (1|bk:geno),
              weights=n_plants,
              family="binomial",
              data=dat60_90)
```


```{r}
anova(mod3, mod3.1, test = "Chisq")
AIC(mod3, mod3.1)
```


```{r}
summary(mod3)
```

log odds A = -5.33987 + 2.041 days
log odds B = (-5.33987 + 0.053) + (2.041 -0.036) days

```{r}
tab_model(mod3)
```

geno [B] * days = 0.96 (0.93 - 0.99); p =0.023

```{r}
plot_model(mod3, 
           terms = c("days", "geno"), 
           type='pred', show.data=T)

em3 <- emmeans(mod3, ~ geno|days, type="response")

res3 <- cld(em3, Letters = letters, alpha = .05, type = "response")
knitr::kable(res3)
```

#· Serie full

```{r}
head(dat)
dat %>% 
  ggplot() +
  aes(x=days, y=inc_prop, col=geno, shape=bk)+
  geom_point()

mod_serie <- glmer(inc_prop ~ geno * days + 
                     (1|bk) + (1|bk:geno),    # aleatorio bk y parcela 
              weights=n_plants,
              family="binomial",
              data=dat) 
plot_model(mod_serie, 
           terms = c("days", "geno"), 
           type='pred', show.data=T)
```

```{r}
# Sacamos el efecto del genotipo


mod_serie0 <- glmer(inc_prop ~ days +  
    (1|bk) + (1|bk:geno),
              weights=n_plants,
              family="binomial",
              data=dat) 

mod_serie1 <- glmer(inc_prop ~ days + geno +   
    (1|bk) + (1|bk:geno),
              weights=n_plants,
              family="binomial",
              data=dat) 
```

## Seleccion de modelo

```{r}
anova(mod_serie0, mod_serie1, mod_serie, test = "Chisq")
AIC(mod_serie0, mod_serie1, mod_serie)
```

```{r}
summary(mod_serie)

tab_model(mod_serie)
plot_model(mod_serie, type = "pred", terms = c("days", "geno"))
```


Pred. lineal geno A = -3.18 + 0.024 * days
(dias significativo para el geno A, ya que conforme transcurren los dias la incidencia aumenta)

Pred. lineal geno B = (-3.275 + 0.147) + (0.025 + 0.99) * days 


## Prediccion

```{r}

ggpredict(mod_serie, c( "days", "geno"))

ggpredict(mod_serie, 
          terms = "days [100:110]", condition = c(geno = c("A")))

ggpredict(mod_serie, 
          terms = "geno", 
          condition = c(days = "100"))
```


```{r}
pacman::p_load(DHARMa)

mod_serie %>% testOutliers()
mod_serie %>% testDispersion()
```


